<!DOCTYPE html>
<html dir="ltr" lang="en-US">
<head>
	<meta charset="UTF-8" />
    <title>An in depth look at for loops | Greg Young</title>
	<link rel="profile" href="http://gmpg.org/xfn/11" />
	
	<link href="http://feeds.feedburner.com/CodeBetter" title="CodeBetter.Com &raquo; Feed" type="application/rss+xml" rel="alternate">
	
		<link rel="pingback" href="http://codebetter.com/gregyoung/xmlrpc.php" />
	                <link rel="stylesheet" href="http://codebetter.com/gregyoung/wp-content/uploads/spacker-cache/ea73517eb74a545f51c376487c94dc9f.css" type="text/css" media="all" /><!-- Is Cache! -->
                <script type='text/javascript' src='http://codebetter.com/gregyoung/wp-includes/js/l10n.js?ver=20101110'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://codebetter.com/gregyoung/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://codebetter.com/gregyoung/wp-includes/wlwmanifest.xml" /> 
<link rel='index' title='Greg Young' href='http://codebetter.com/gregyoung/' />
<link rel='start' title='Howdy and Viewing Unmanaged Code in VS.NET' href='http://codebetter.com/gregyoung/2006/06/09/howdy-and-viewing-unmanaged-code-in-vs-net/' />
<link rel='prev' title='Performance Measurement' href='http://codebetter.com/gregyoung/2006/06/10/performance-measurement/' />
<link rel='next' title='For loop follow up (Disagreeing with Richter?!)' href='http://codebetter.com/gregyoung/2006/06/13/for-loop-follow-up-disagreeing-with-richter/' />
<meta name="generator" content="WordPress 3.1-beta1-16732" />
<link rel='canonical' href='http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/' />
<link rel='shortlink' href='http://codebetter.com/gregyoung/?p=7' />
<link rel="stylesheet" href="http://codebetter.com/gregyoung/wp-content/plugins/digg-digg/include/../css/diggdigg-style.css?ver=4.5.0.7" type="text/css" media="screen" /><meta id="syntaxhighlighteranchor" name="syntaxhighlighter-version" content="3.1.1" />
                <script type="text/javascript" src="http://codebetter.com/gregyoung/wp-content/uploads/spacker-cache/a8046d2f1fc1c08af413701218a11c1d.js">/*Is Cache!*/</script>
                	<style type="text/css">body { padding-top:0px !important; } html { margin-top: 0px !important; }</style>

</head>

<body>

			
		<div class="container_12 ui-tabs ui-widget ui-widget-content ui-corner-all" id="tabs">			
			<ul class="ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all">
				<li class="ui-state-default ui-corner-top ui-tabs-selected ui-state-active"><a href="#ui-tabs-1">CodeBetter.Com</a></li>
				<li class="ui-state-default ui-corner-top"><a href="http://devlicio.us">Devlicio.Us</a></li>				
				<div id="top-search">
				<form action="http://codebetter.com/globalsearch/" id="cse-search-box">
  <div>
   <fieldset id="search">
		<input type="hidden" name="cx" value="005178204031477491434:2bg5jtwgsfe" />
		<input type="hidden" name="cof" value="FORID:9" />
		<input type="hidden" name="ie" value="UTF-8" />
		<input type="text"  class="text-input" id="s" name="q" size="31" />
		<input type="image" src="http://cdn1.codebetter.com/wp-content/themes/codebetter/images/search-img.png" class="form-button" id="searchsubmit" value="GO" name="">				   	
	</fieldset>
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&lang=en&sitesearch=true"></script>
				</div>				
			</ul><div id="ui-tabs-1" class="ui-tabs-panel ui-widget-content ui-corner-bottom"></div><div id="ui-tabs-2" class="ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide"></div>
		</div>
			
		<div id="main" class="container_12">
		
			<div id="logo" class="grid_3"><a href="/" title="CodeBetter.Com - Stuff you need to Code Better!"><image src="http://cdn1.codebetter.com/wp-content/themes/codebetter/images/codebetter_logo.png" height="48" width="223"></image></a></div>
			<div id="ad_leaderboard" class="grid_9">			</div>
			
			<div id="globalNav" class="grid_12">
				<ul>
					<li><a href="http://codebetter.com" title="home">Home</a></li>
					<li class="page_item page-item-2"><a href="http://codebetter.com/about/" title="About">About</a></li>
<li class="page_item page-item-8"><a href="http://codebetter.com/codebetter-ci/" title="CodeBetter CI">CodeBetter CI</a></li>
<li class="page_item page-item-6"><a href="http://codebetter.com/community/" title="Community">Community</a></li>
<li class="page_item page-item-10"><a href="http://codebetter.com/editors/" title="Editors">Editors</a></li>
					<li><a href="http://feeds.feedburner.com/CodeBetter" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon16x16.png" alt="" style="vertical-align:middle;border:0"/></a><a href="http://feeds.feedburner.com/CodeBetter"><img src="http://feeds.feedburner.com/~fc/CodeBetter?bg=EFEFEF&amp;fg=2E9BD2&amp;anim=1" height="26" width="88" style="vertical-align:middle;border:0"/></a></li>
				</ul>
								
			</div><!-- end div#globalNav.container_12 -->				
	
		<div id="content" class="container_12">
			<div id="main" class="grid_8">


				<div id="post-7" class="post-7 post type-post status-publish format-standard hentry category-under-the-covers">
					<h1 class="entry-title">An in depth look at for loops</h1>

					<div class="entry-meta">
						<span class="meta-prep meta-prep-author">Posted by </span>
						<span class="author vcard"><a class="url fn n" href="http://codebetter.com/gregyoung/author/gregyoung/" title="View all posts by gregyoung">gregyoung</a></span>
						<span class="meta-sep"> on  </span>
						<a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/" title="11:08 pm" rel="bookmark"><span class="entry-date">June 11, 2006</span></a>
											</div><!-- .entry-meta -->

					<div class="entry-content">
						<div id="greet_block"><noscript><div class="greet_block wpgb_cornered"><div class="greet_text"><div class="greet_image"><a href="http://codebetter.com/gregyoung/feed/rss/"  rel="nofollow"><img src="http://codebetter.com/gregyoung/wp-content/plugins/wp-greet-box/images/rss_icon.png" alt="WP Greet Box icon"/></a></div>Hello there! If you are new here, you might want to <a href="http://codebetter.com/gregyoung/feed/rss/" rel="nofollow"><strong>subscribe to the RSS feed</strong></a> for updates on this topic.<div style="clear:both"></div><div class="greet_block_powered_by">Powered by <a href="http://omninoggin.com/projects/wordpress-plugins/wp-greet-box-wordpress-plugin/" title="WP Greet Box WordPress Plugin" style="text-decoration:none;">WP Greet Box</a> <a href="http://omninoggin.com/" title="WordPress Plugin" style="text-decoration:none;">WordPress Plugin</a></div><div style="clear:both"></div></div></div></noscript></div><p><P class="MsoNormal"><FONT face="Calibri">My last two posts have been about </FONT><A HREF="/blogs/gregyoung/archive/2006/06/10/146318.aspx"><FONT face="Calibri">Performance Measurement</FONT></A><FONT face="Calibri"> and </FONT><A HREF="/blogs/gregyoung/archive/2006/06/09/146298.aspx"><FONT face="Calibri">Viewing Unmanaged Code in VS.NET</FONT></A><FONT face="Calibri">, these posts while rather interesting have really been to set us up for the this discussion. If you have not read these posts you may want to as I will be using information from them often in this post. </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">There are a lot of posts on the Internet discussing varying methods of looping using <B>for </B>loops and which perform best. These posts also generally give advice as to how you should handle your looping based upon performance metrics. Most of these types of posts suffer from an affliction I have discussed previously; they look at IL (Intermediate Language) to rationalize performance which is just flat out wrong as subtle differences can cause JIT (Just in Time) optimizations to go haywire. </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">In this post we will look at the unmanaged code produced by varying constructs to come up with a definitive answer to the performance question. We will also look at some other optimization methods that people claim happen but do not always happen and discuss some reasons why they may not be happening and of course set some rules for fast looping.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">In trying to apply this the version of your framework is important as the JIT may vary from version to version, I do not believe anything here will change based upon the platform but that is a possibility. I used version 2.0.50727 for all examples in this document. Other versions such as Rotor, Mono, or 1.x <SPAN>&nbsp;</SPAN>will most likely show differing behaviors.</FONT></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Hoisting?</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">Before I start getting into code I would like to discuss the concept of hoisting as it will be the focal point of this entire discussion. When dealing with loops we can break any given loop into three sections</FONT></P><br />
<P class="MsoListParagraphCxSpFirst"><SPAN><SPAN><FONT face="Calibri">1)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">The preamble (setting up for the loop, doing things such as setting our counter to 0)</FONT></P><br />
<P class="MsoListParagraphCxSpMiddle"><SPAN><SPAN><FONT face="Calibri">2)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">The code within the loop</FONT></P><br />
<P class="MsoListParagraphCxSpLast"><SPAN><SPAN><FONT face="Calibri">3)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">The code to increment our counter and check for the end of iteration&nbsp;possibly jumping back to step two</FONT></P><br />
<P class="MsoNormal"><I><FONT face="Calibri">For the rest of this post I will color code the disassembled assembly as section one (green), section two (blue), section 3 (yellow) to make things easier to follow</FONT></I></P><br />
<P class="MsoNormal"><FONT face="Calibri">Any code that is in step two or three will be run N times as the loop is executed. The code in step one will only be executed a single time when we first enter the loop. The concept of hoisting involves moving code out of steps two and three and&nbsp;into step one. Hoisting obviously gives you a huge performance gain as the code will only be run once.<SPAN>&nbsp; </SPAN><I></I></FONT></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Simple Hoisting Example</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">If you read alot&nbsp;articles on for loop performance&nbsp;they will tell you to not manually hoist because the JIT will end up doing it for you. In order to test this I have created the following test code (which can be used in conjunction with the harness discussed in the previous </FONT><A HREF="/blogs/gregyoung/archive/2006/06/10/146318.aspx"><FONT face="Calibri">Performance Measurement</FONT></A><FONT face="Calibri"> post)</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN><SPAN>class</SPAN> <SPAN>Program</SPAN> {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN>[] foo = <SPAN>new</SPAN> <SPAN>int</SPAN>[100000];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> Dummy;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Test1NoHoist() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total|=i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Dummy = total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Test1WithHoist() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> length = foo.Length;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total|=i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Dummy = total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Main(<SPAN>string</SPAN>[] args) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>TestHarness</SPAN>.Test(<SPAN>&#8220;Test1NoHoist&#8221;</SPAN>, 10000, <SPAN>new</SPAN> <SPAN>TestHandler</SPAN>(Test1NoHoist));</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>TestHarness</SPAN>.Test(<SPAN>&#8220;Test1WithHoist&#8221;</SPAN>, 10000, <SPAN>new</SPAN> <SPAN>TestHandler</SPAN>(Test1WithHoist));</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>Console</SPAN>.ReadLine();</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 1: Basic manual hoisting example</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">You will quickly notice that in Test1WithHoist we manually took the check Length property on foo and moved it to before the loop; this is a common optimization if you come from a C/C++ world. The thought behind this is that since Length translates to get_Length() that we are saving ourselves from having to call the method n times (remember that this would be in the second or third section and everything in the third section is called n times).</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">An astute reader will notice an oddity dealing with the “Dummy” variable that is assigned after the loop. We will come back this a bit later on… good catch <img src='http://codebetter.com/gregyoung/wp-includes/images/smilies/icon_wink.gif' alt=';)' class='wp-smiley' /> </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">The by running our performance test, we can see that the code executes in roughly equivalent time.<SPAN>&nbsp; </SPAN></FONT></P><br />
<TABLE class="LightList-Accent1" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Test</FONT></SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Total Time (ns)</FONT></SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Average (ns)</FONT></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1NoHoist</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>820583612.35 </SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>82058.36</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1WithHoist</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>812735363.70 </SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>81273.53</SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Let’s take a look at the generated code to offer proof that the two bits of code should run in equivalent time (if you want to see the results for yourself remember to follow the instructions for getting JIT optimized code from </FONT><A HREF="/blogs/gregyoung/archive/2006/06/09/146298.aspx"><FONT face="Calibri">Viewing Unmanaged Code in VS.NET</FONT></A><FONT face="Calibri">. </FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" width="100%" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal" align="center"><B><SPAN>Test1NoHoist</SPAN></B></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal" align="center"><B><SPAN>Test1WithHoist</SPAN></B></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000004<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000009<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [eax+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000019</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,edx</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000012<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000017<SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000010</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000019<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr ds:[00912FE8h],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001f</SPAN><SPAN><SPAN>&nbsp; </SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;</SPAN></SPAN><SPAN></SPAN></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000007<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,dword ptr [eax+4]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000a<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000019</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,eax</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000012<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000017<SPAN>&nbsp; </SPAN>jl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000010</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000019<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr ds:[00912FE8h],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001f</SPAN><SPAN><SPAN>&nbsp; </SPAN>ret</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 2: Disassembled versions of our functions</FONT></SPAN></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">&nbsp;</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">A kind of neat item in these two bits of code is that the only real difference is that EAX and EDX are interchanged … This makes them look a bit more different than they are but rest assured they are pretty much identical. In both cases, the access to the stop variable has been hoisted out of the loop (in section three, both are comparing their counter to a register that was preloaded in section one). To better illustrate the point, here is a disassembly of the first for loop (without manual hoisting) when run without JIT optimizations (i.e. it will not be hoisted).</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN>0000002a<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002c<SPAN>&nbsp; </SPAN>nop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002d<SPAN>&nbsp; </SPAN>jmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000034 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002f</SPAN><SPAN><SPAN>&nbsp; </SPAN>nop</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000030<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,esi</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000032<SPAN>&nbsp; </SPAN>nop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000033<SPAN>&nbsp; </SPAN>inc<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000034<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;</SPAN>eax,dword ptr ds:[02275A34h] ;inlined length</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000039<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,dword ptr [eax+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003c<SPAN>&nbsp; </SPAN>setl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>al<SPAN>&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003f</SPAN><SPAN><SPAN>&nbsp; </SPAN>movzx<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,al </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000042<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000044<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,ebx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000046<SPAN>&nbsp; </SPAN>jne<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000002F</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;</SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 3: First loop (no hoisting with optimizations disabled) non-important code removed </FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">If this does not convince you to <B>NEVER </B>release code that is not being optimized I don’t know what will. It should also give you an idea of how much work the JIT optimizer really does. What has happened here is that the property was inlined, but it was inlined into section three. The optimizer was smart enough to realize this and to move it up to the preamble. <SPAN>&nbsp;</SPAN>+1 for the optimizer</FONT></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Non-Trivial Hoisting</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">Now that we have gone through a simple example, let’s try a more difficult one for the optimizer. In this example we will use a method GetUpperBound(0) which will not be inlined for us, let’s take a look at how well the JIT handles it. Here is the testing code to add to our previous code.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Test1NoHoistNoInlining() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; foo.GetUpperBound(0); i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Dummy = total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Test1WithHoistNoInlining() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> length = foo.GetUpperBound(0);</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Dummy = total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 4: Tests without inlining available</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Next we should add the following to our Main to run the tests.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>TestHarness</SPAN>.Test(<SPAN>&#8220;Test1NoHoist&#8221;</SPAN>, 10000, <SPAN>new</SPAN> <SPAN>TestHandler</SPAN>(Test1NoHoistNoInlining));</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>TestHarness</SPAN>.Test(<SPAN>&#8220;Test1WithHoist&#8221;</SPAN>, 10000, <SPAN>new</SPAN> <SPAN>TestHandler</SPAN>(Test1WithHoistNoInlining));</SPAN></P><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 5: Calling our new methods</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">When we run the tests in release mode, we get quite different results than previously. I am including the previous results in the table for comparison.</FONT></P><br />
<TABLE class="LightList-Accent1" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Test</FONT></SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Total Time (ns)</FONT></SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="center"><SPAN><FONT face="Calibri">Average (ns)</FONT></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1NoHoist</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>820583612.35 </SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>82058.36</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1WithHoist</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>812735363.70 </SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>81273.53</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1NoHoistNoInlining</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>25457518879.48</SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>2545751.88</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal"><FONT face="Calibri">Test1WithHoistNnInlining</FONT></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>824641533.67</SPAN></P></TD><br />
<TD vAlign="top" width="213"><br />
<P class="MsoNormal" align="right"><SPAN>82464.15</SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Interesting, not manually hoisting makes our function 32x slower. Before we even get into code on this one I will put my money on the optimizer not hoisting the call. I believe however there are some reasons for this that we will discuss after looking through the code.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" width="100%" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal" align="center"><B><SPAN>Test1NoHoistNoInlining</SPAN></B></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal" align="center"><B><SPAN>Test1WithHoistNoInlining</SPAN></B></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN>00000004<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000006<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792661F8 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000017<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000031</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000019<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,esi</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001b<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001e<SPAN>&nbsp; </SPAN>mov <SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>ecx,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000024<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000026<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000028<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792661F8 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002d<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002f</SPAN><SPAN><SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000019</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;</SPAN></SPAN></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN>00000003<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000009<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000b<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000d<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792661A8 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000012<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000014<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000016<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000018<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000023</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001a<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;</SPAN>esi,eax</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001c<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001f</SPAN><SPAN><SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000021<SPAN>&nbsp; </SPAN>jl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000001A</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN></SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 6: Disassembled versions<SPAN></SPAN></FONT></SPAN></P></TD><br />
<TD vAlign="top" width="50%"><br />
<P class="MsoNormal"><SPAN></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">As we suspected the code on the left hand side is not automatically hoisting the call of the function for us.<SPAN>&nbsp; </SPAN>It would seem that the JIT will not automatically hoist method calls for us, that instead we have to explicitly state that we want them hoisted on our own. </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">It seems that that the JIT cannot get to the point of having a value in a register or memory that it can consider its result and as such feels the need to make the call on every iteration. This would make sense in general as I may be depending upon the behavior of being called at every interval. Consider the following code.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> t = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>bool</SPAN> KeepGoing() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>Console</SPAN>.WriteLine(<SPAN>&#8220;Still Going!&#8221;</SPAN>);</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>t++;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> t &lt; 10;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> TestShortMethod() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (; KeepGoing();) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>System.Threading.<SPAN>Thread</SPAN>.Sleep(100);</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 7: Odd but valid code</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Obviously this is nasty code but it is still valid. This is a simplified example it appears that it was a conscious decision to not support these types of situations as they can quickly become extremely complex from the JIT point of view, my guess is that it won’t deal with anything beyond simply returning a variable which will be inlined into a simple read anyway.<SPAN>&nbsp; </SPAN>In my opinion, something like this should still be inlined (and left in section 3) to avoid the overhead of setting up the call on every iteration but I may be missing some other case that makes this more difficult. Based upon these results we can create the following rule.</FONT></P><br />
<P class="MsoNormal"><STRONG><FONT face="Calibri">If you wish to use a method call for your stop condition that does anything more complex than simply returning a variable or is&nbsp;not inlinable for&nbsp;other reasons such as being virtual;&nbsp;you should hoist it manually by placing it in the first part of your for loop in order to make it explicit to the JIT that you do not wish the behavior to be called on every iteration.</FONT></STRONG></P><FONT face="Calibri"><br />
<P class="MsoNormal"><SPAN>&nbsp;Mark Lubischer brought up an excellent point here. We can in fact also hoist the call by using for&nbsp;like this.</SPAN></P><br />
<P class="MsoNormal"><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="734"><br />
<P class="MsoNormal"><br />
<P class="MsoNormal"><SPAN></SPAN></P><SPAN></SPAN><br />
<P></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> MarkWithoutInlining() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN>[] length = <SPAN>new</SPAN> <SPAN>int</SPAN>[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0, j = length.GetUpperBound(0); i &lt; j; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR></TBODY></TABLE></P><br />
<P class="MsoNormal">&nbsp;</P><br />
<P class="MsoNormal">This is a much better way of handling our hoisting as it better defines the scope of our variable while the behavior is in fact equivalent to our original hoist.</P><br />
<P class="MsoNormal"><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="734"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static int MarkWithoutInlining() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000001<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000003<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,ebx </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int[] length = new int[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000005<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,2710h </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000a<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,7915982Ah </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000f</SPAN><SPAN><SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>FFB21D98 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000014<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>&nbsp;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000016<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000018<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,edi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001a<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001c<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001e<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792664C8 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000023<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000025<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000039 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000027<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,dword ptr [edi+4]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= length[i];</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002a<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002c<SPAN>&nbsp; </SPAN>jae<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000003F </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002e<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,dword ptr [edi+esi*4+8]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000032<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000035<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000037<SPAN>&nbsp; </SPAN>jl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000002A</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return total;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000039<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,ebx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003b<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003c<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003d<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003e <SPAN>&nbsp;</SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003f</SPAN><SPAN><SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792B42E9 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000044<SPAN>&nbsp; </SPAN>int<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>3</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P></TD></TR></TBODY></TABLE></FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri"></FONT>&nbsp;</P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">A Bit About Foreach</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">Foreach is not an IL concept, it is a compiler concept. Compilers generate normal for loops when they see a foreach being used to iterate an array. If you are interested in seeing how foreach loops work I would highly recommend taking a look with ILDASM or Reflector. I will not discuss heavily foreach loops as they have at this moment no difference when they reach the native level.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Foreach could in the future offer many benefits over a general for loop. Since the foreach loop is explicitly stating that you want to iterate through the array (not allowing things like addition and subtraction to your counter), other things such as hoisting array bounds checks (which we will discuss shortly) would be much more easily accomplished. I would imagine that in the future foreach will be the preferred iteration construct.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">I will assure you though that as of now foreach is <B>not</B> faster than the equivalent for loop when dealing with arrays, in fact both VB.NET and C# insure that they are identical. There is one case where foreach will be slower than a for loop and that is if you do not actually use the item within your loop, the for version will obviously be faster since it never loads the variable where as the foreach does this implicitly on every iteration. Foreach can however offer you great performance increases when dealing with other types that implement IEnumerable (not including collections as they simply perform an indexed lookup in their enumerator). </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Logically one can come up with a great example for this when looking at a linked list. The for loop will cause ∑ n total operations on the iteration where as the foreach will only cause n. The reason for this is every index operation would have to start at the beginning of the list and iterate n nodes in order to return the nth node where as the enumerator will simply remember the last node it was on and give the next node. For this reason we will add our second rule.</FONT></P><br />
<P class="MsoNormal"><B><FONT face="Calibri">When dealing with items that are enumerable as opposed to dealing with arrays or collections; prefer foreach to a for loop as the enumerator will often offer a much faster way of enumerating than using an index.</FONT></B></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Array Bounds Check Hoisting</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">The check to find out whether or not we are valid to continue is not the only thing that can be hoisted from inside of a loop. In fact every time the variable is used in a comparison within the loop is an opportunity for hoisting to occur. The first example of this type of hoist we will look at is array bounds checking.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Array bounds are checked automatically by the CLR in order to prevent things like buffer overflows from occurring. Every time that you access an array in safe code you will in fact have a comparison occur to insure that you are within the range of the array. If you are not within a valid range an IndexOutOfRangeException will occur as opposed to writing happily beyond the end of your array as many other language such as C would do.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">The problem with array bounds checks is that they are extremely redundant when dealing with loops. Consider the following code that shows what is happening.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> SampleArrayBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>if</SPAN> (i &lt; foo.Length) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 9: Sample Array Bounds Code</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Naturally you are not issuing these checks in your code, but this example helps to make what’s really going on a bit clearer. When looking at this code anyone who has read the first few chapters of a C# book would scratch their head and wonder why all of the redundancy has been placed into the code. It is obvious that if our counter has a constraint to stay below foo.Length that it will in fact always succeed the conditional of being below foo.Length. To test how intelligent the JIT is with handling this situation we can use the following code. Note that for this test we will simply be looking at the native code generated as opposed to measuring performance.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> [] SampleArrayBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> [] Destination = <SPAN>new</SPAN> <SPAN>int</SPAN>[foo.Length];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Destination[ i ]= foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> Destination;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 10: Test to see if array bound checks hoist</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">This code is simply copying the static array that we have been using previously to another array. This code should be particularly good to test as it in fact has two bounds checks occurring within it (one for each array).</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static int [] SampleArrayBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int [] Destination = new int[foo.Length];</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000001<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000003<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebp<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000004<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000005<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000b<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,dword ptr [edi+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,ebx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,7915982Ah </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015 <SPAN>&nbsp;</SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>FFB21FC0 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001a<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001c<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001e<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,ebx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000020<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000045 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000022<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebp,dword ptr [edi+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000025<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [esi+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000028<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [esp],eax</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Destination[ i ]= foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002b<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,ebp </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002d<SPAN>&nbsp; </SPAN>jae<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000004D </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002f</SPAN><SPAN><SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,dword ptr [edi+edx*4+8] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000033<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [esp] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000036<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000038<SPAN>&nbsp; </SPAN>jae<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000004D </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003a<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [esi+edx*4+8],ecx</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003e<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000041<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000043<SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>0000002B</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return Destination;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000045<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000047<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000048<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebp<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000049<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ebx<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000004a<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000004b<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000004c<SPAN>&nbsp; </SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000004d<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792B4511 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000052<SPAN>&nbsp; </SPAN>int<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>3</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 11: Disassembly of simple array bound checks</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Unfortunately even this most trivial of examples does not hoist the array bounds checks. The jumps can clearly be seen on lines 2D and 38. <SPAN>&nbsp;</SPAN>As to why this does not work I am not sure but perhaps it is because code like this could exist which could cause a buffer overflow? Perhaps the amount of time detect this situation has been deemed too much.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> [] SampleArrayBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> [] Destination = <SPAN>new</SPAN> <SPAN>int</SPAN>[foo.Length];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; 100000; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>i += 100000000;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Destination[ i ]= foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> Destination;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 12: Buffer overfow example</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Checking before applying the optimization would require a good amount of overhead and if it did not check to make sure anyone was messing with our counter in the interior of the loop then we could run into code like this which would cause a buffer overflow (who knows what we just wrote over, maybe we would get an exception or maybe we just caused a funny character in a string some place, boy do I miss the days of C/Pascal in embedded systems </FONT><SPAN><SPAN>J</SPAN></SPAN><FONT face="Calibri">).<SPAN>&nbsp; </SPAN>Let’s try something even simpler, </FONT><A href="http://blogs.msdn.com/brada/archive/2005/04/23/411321.aspx"><FONT face="Calibri">Brad Abrams says it works</FONT></A><FONT face="Calibri"> so it must?</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> SampleArrayConstantBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> foo2 = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; 1000; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>foo2 = foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> foo2;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static int SampleArrayConstantBoundsCheck() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int foo2 = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0; i &lt; 1000; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000001<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000003<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN>ecx,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000009<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,dword ptr [ecx+4]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>foo2 = foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>jae<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000021 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [ecx+edx*4+8]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0; i &lt; 1000; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000014<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000017<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,3E8h </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001d<SPAN>&nbsp; </SPAN>jl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000000C</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001f</SPAN><SPAN><SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return foo2;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000020<SPAN>&nbsp; </SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000021<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792B44A9 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000026<SPAN>&nbsp; </SPAN>int<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>3</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 13: Simplest possible example</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Again, no love from the JIT optimizer, we cannot possibly make this example any simpler but it still has the bounds checks firmly placed within our loop. The JIT optimizer does <B>not </B>hoist array bounds checks for you. My guess is that it will not do this do to threading reasons, I would assume the process to actually be thread safe (as it is only copying something of reference size which is assured to be atomic but I am probably missing something. There is some similar functionality which happens that I think may cause the confusion that array bounds hoist are actually occurring. Let’s take a look at this other optimization, but first we can make a new rule.</FONT></P><br />
<P class="MsoNormal"><B><FONT face="Calibri">If you are dealing with array accesses in a highly performant area and the bounds checks being in the loop are too much. You will have to handle your iteration in unsafe code to remove the bounds checks.</FONT></B></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Local Array Bounds Check Removal</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">The optimization that the JIT does support is removing bounds checks for locally created arrays. Since the array has been created locally and is only known by a local reference, the JIT can be sure that the array cannot possibly change. In these cases the JIT will completely remove bounds checks. Let’s take a look at an example.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> TestLocalArrayBoundsCheckRemoval() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> [] Test = <SPAN>new</SPAN> <SPAN>int</SPAN>[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN>(<SPAN>int</SPAN> i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= Test[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> total;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static int TestLocalArrayBoundsCheckRemoval() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int[] Test = new int[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000001<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,2710h </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000006<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,7915982Ah </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000b<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>FFB21FF0 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000010<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000012<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000014<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000016<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [ecx+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000019<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001b<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000028</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= Test[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001d<SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,dword ptr [ecx+edx*4+8]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000021<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000024<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000026<SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000001D</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return total;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000028<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002a<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002b<SPAN>&nbsp; </SPAN>ret</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 14: Removal of local array bounds</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">What is really neat here is that we have in fact created unmanaged code which does not even check for out of bounds access. This code will never throw an exception (it doesn’t even have code to throw an exception). This optimization is even better than hoisting as it has no overhead, the hoisting would make it a single comparison; this had <B>no </B>comparison. My guess is that people were getting confused between this and hoisting. If you do not use a length property or a constant in your loop this optimization will not occur, as an example the following code will not remove the bounds checks</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> SampleArrayConstantBoundsCheckRemoval() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> foo2 = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> size = foo.GetUpperBound(0) ;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; size; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>foo2 = foo[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> foo2;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static int TestLocalArrayBoundsCheckRemoval() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int[] Test = new int[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000001<SPAN>&nbsp; </SPAN>push<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,2710h </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000007<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,7915982Ah </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>FFB21FF0 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000011<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000013<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,edi </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int size = Test.GetUpperBound(0);</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,esi </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000017<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000019<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx],ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001b<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>79266720 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000020<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,eax</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;size;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000022<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000024<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000026<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000003A </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000028<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,dword ptr [esi+4]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total |= Test[ i ];</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002b<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002d<SPAN>&nbsp; </SPAN>jae<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000003F </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000002f</SPAN><SPAN><SPAN>&nbsp; </SPAN>or<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi,dword ptr [esi+eax*4+8]</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;size;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000033<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000036<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000038<SPAN>&nbsp; </SPAN>jl<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000002B</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return total;</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003a<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edi </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003c<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>esi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003d<SPAN>&nbsp; </SPAN>pop<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edi<SPAN>&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003e<SPAN>&nbsp; </SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN>0000003f</SPAN><SPAN><SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>792B4541 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000044<SPAN>&nbsp; </SPAN>int<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>3<SPAN>&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 15: Manual hoisting causes Array Bounds Check Removal to fail</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">As we can see the manual hoisting caused the optimization to fail. So manual hoisting is not always a good thing as it can break some JIT patterns such as this. This optimization will also work for writes.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>int</SPAN> [] TestLocalArrayBoundsCheckWrite() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN>[] Test = <SPAN>new</SPAN> <SPAN>int</SPAN>[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN>(<SPAN>int</SPAN> i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Test[ i ] = i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>return</SPAN> Test;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp; </SPAN>static int [] TestLocalArrayBoundsCheckWrite() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int[] Test = new int[10000];</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,2710h </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000005<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,7915982Ah </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000a<SPAN>&nbsp; </SPAN>call<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>FFB21FF0 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000f</SPAN><SPAN><SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ecx,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000011<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000013<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [ecx+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000016<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000018<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000025</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Test[ i ] = i;</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001a<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>dword ptr [ecx+edx*4+8],edx</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for(int i=0;i&lt;Test.Length;i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>0000001e<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000021<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000023<SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000001A</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return Test;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000025<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,ecx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000027<SPAN>&nbsp; </SPAN>ret</SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Listing 16: Bounds Check Removal for writes </FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">As we can see, it again removed all of the bounds checking. Of course as we have seen earlier, this will only work for an array that is created in the same method. If we move the creation of the array out of the method this optimization will no longer occur. This leads us to our third rule.</FONT></P><br />
<P class="MsoNormal"><B><FONT face="Calibri">Try to keep creation and initialization of arrays within the same method as the JIT can often times remove the bounds checks during your initialization.</FONT></B></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Another oddity</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">Were you one of the people I said “good catch” to earlier? Remember those odd “Dummy” variables were using in the first set of examples</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">The JIT is extremely smart in some optimizations. For example it realizes if you are doing calculations and never use the result, it will remove the code for you. It does however have a slight problem when dealing with loops. Let’s try removing those Dummy calls from our previous code and see what happens. Let’s take a look at only one of them since we have already shown that they produce identical results.</FONT></P><br />
<TABLE class="MsoTableGrid" cellSpacing="0" cellPadding="0" border="1"><br />
<TBODY><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>static</SPAN> <SPAN>void</SPAN> Test1NoHoist() {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>int</SPAN> total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN>for</SPAN> (<SPAN>int</SPAN> i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>total|=i;</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>static void Test1NoHoist() {</SPAN></SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int total = 0;</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000000<SPAN>&nbsp; </SPAN>xor<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,edx</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for (int i = 0; i &lt; foo.Length; i++) {</SPAN></P><br />
<P class="MsoNormal"><SPAN>00000002<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr ds:[022B1EC4h] </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000007<SPAN>&nbsp; </SPAN>mov<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,dword ptr [eax+4] </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000a<SPAN>&nbsp; </SPAN>test<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,eax </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000c<SPAN>&nbsp; </SPAN>jle<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>00000015 </SPAN></P><br />
<P class="MsoNormal"><SPAN>0000000e<SPAN>&nbsp; </SPAN>add<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>edx,1 </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000011<SPAN>&nbsp; </SPAN>cmp<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>eax,edx </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000013<SPAN>&nbsp; </SPAN>jg<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>0000000E</SPAN><SPAN> </SPAN></P><br />
<P class="MsoNormal"><SPAN>00000015<SPAN>&nbsp; </SPAN>ret<SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN></SPAN></P></TD></TR><br />
<TR><br />
<TD vAlign="top" width="638"><br />
<P class="MsoNormal"><SPAN><FONT face="Calibri">Figure 17: Our method without the dummy value being set</FONT></SPAN></P></TD></TR></TBODY></TABLE><br />
<P class="MsoNormal"><FONT face="Calibri">&nbsp;</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">I have color coded the example as with the rest of the example.<SPAN>&nbsp; </SPAN>You will notice that the blue section is missing. The JIT optimizer has correctly realized that we were in fact never using our total variable after we performed all of the calculation on it. It has however failed to realize that by taking out our code, it has in fact left a loop which does nothing. Nothing super interesting here, this is just something I came across while writing this.</FONT></P><br />
<H1><FONT face="Cambria" color="#385b86" size="5">Summary</FONT></H1><br />
<P class="MsoNormal"><FONT face="Calibri">We have looked through quite a few JIT optimizations in this post and have made a few rules which that can help us in situations where measuring becomes very difficult as we need to know what to measure against. Let’s go back through our rules, keep in mind that these rules are not version agnostic so using 1.x, mono, or rotor you will likely get different results!</FONT></P><br />
<P class="MsoListParagraphCxSpFirst"><SPAN><SPAN><FONT face="Calibri">1)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">If you wish to use a method call for your stop condition that does anything more complex than simply returning a variable or is not inlinable for other reasons such as it being virtual,&nbsp;you should hoist it manually in order&nbsp;by placing it in the first part of your for loop<STRONG>&nbsp;</STRONG>to make it explicit to the JIT that you do not wish the method to be called on every iteration.</FONT></P><br />
<P class="MsoListParagraphCxSpMiddle"><SPAN><SPAN><FONT face="Calibri">2)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">When dealing with items that are enumerable as opposed to dealing with arrays or collections; prefer foreach to a for loop as the enumerator will often offer a much faster way of enumerating than using an index.</FONT></P><br />
<P class="MsoListParagraphCxSpMiddle"><SPAN><SPAN><FONT face="Calibri">3)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">If you are dealing with array access in a highly performant area and the bounds checks being in the loop are too much overhead. You will have to handle your iteration in unsafe code to remove the bounds checks (in other words, it is impossible to write performant looping code in VB.NET)</FONT></P><br />
<P class="MsoListParagraphCxSpLast"><SPAN><SPAN><FONT face="Calibri">4)</FONT><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><FONT face="Calibri">Try to keep creation and initialization of arrays within the same method as the JIT can often times remove the bounds checks during your initialization.</FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">Hopefully by following these rules you can save yourself some time the next time you are optimizing code as many of these rules deal with things that are difficult to measure, but remember measurement is key. </FONT></P><br />
<P class="MsoNormal"><FONT face="Calibri">I hope you enjoyed reading about these optimizations as much as I enjoyed writing about them.</FONT></P></p>
											</div><!-- .entry-content -->


					<div class="entry-utility">
					This entry was posted in <a href="http://codebetter.com/gregyoung/category/under-the-covers/" title="View all posts in Under The Covers" rel="category tag">Under The Covers</a>. Bookmark the <a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/" title="Permalink to An in depth look at for loops" rel="bookmark">permalink</a>. Follow any comments here with the <a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/feed/" title="Comments RSS to An in depth look at for loops" rel="alternate" type="application/rss+xml">RSS feed for this post</a>.
					</div><!-- .entry-utility -->
				</div><!-- #post-7 -->

				<div id="nav-below" class="navigation">
					<div class="nav-previous"><a href="http://codebetter.com/gregyoung/2006/06/10/performance-measurement/" rel="prev"><span class="meta-nav">&larr;</span> Performance Measurement</a></div>
					<div class="nav-next"><a href="http://codebetter.com/gregyoung/2006/06/13/for-loop-follow-up-disagreeing-with-richter/" rel="next">For loop follow up (Disagreeing with Richter?!) <span class="meta-nav">&rarr;</span></a></div>
				</div><!-- #nav-below -->

							<div id="comments">


			<h3 id="comments-title">7 Responses to <em>An in depth look at for loops</em> </h3>


			<ol class="commentlist">
						<li class="comment even thread-even depth-1" id="li-comment-13">
		<div id="comment-13">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">ole johnny</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-13">February 2, 2009 at 10:39 pm</a></div>

		<div class="comment-body"><p>Any worthwhile updates on the latest .Net 3.5 JIT optimization?</p>
<p>Given the following code:<br />
       int[] data= new int[100000000];<br />
       for (int i = 0; i < 100000000; i++)<br />
       {<br />
           data[i]= i;<br />
       }<br />
I get less than 1 GB per second transfere rate on my laptop which should be good for 8GB a second (got two identical memory modules). I have tried various alternatives including unsafe code as well as adding multiple arrays within the loop. I am running optimized release mode from outside visual studio.</p>
<p>Is this as it should be, why, how and when to utilize max memory transfere? </p>
<p>If this simple code cant get closer to the max I dont know what will&#8230;</p>
<p>Appreciate your articles, absolutely great reading!<br />
OJ</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12">
		<div id="comment-12">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">Greg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-12">June 30, 2006 at 3:36 pm</a></div>

		<div class="comment-body"><p>I am curious on your source derek &#8230; this is not the case.</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment even thread-even depth-1" id="li-comment-11">
		<div id="comment-11">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">derekdb</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-11">June 17, 2006 at 5:32 am</a></div>

		<div class="comment-body"><p>My understanding was that the Jit optimizer only hoisted bounds checks when the code directly tested against array.length.  I&#8217;ve actually seen code of the form<br />
for (int i=0; i < foo.length; i++) { if (i < 1000) break; &#8230; with the claim that this hoisted the bounds check out of the loop.  I can&#8217;t verify this right now, so I leave that as an exersize for the reader..</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-10">
		<div id="comment-10">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">Greg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-10">June 17, 2006 at 5:03 am</a></div>

		<div class="comment-body"><p>I have some further information on the removal case that I will be posting .. I am waiting to hear back on a few things before I post. Basically if you assign a static/instance to a local variable removal will occur (but often times your explictness is also optimized out). I am trying to figure out if this is a bug or not and whether or not this should be considerred a best practice in 2.0 as the same optimization may in fact incur a penalty dealing with other JITs.</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment even thread-even depth-1" id="li-comment-9">
		<div id="comment-9">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">Mark Lubischer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-9">June 13, 2006 at 4:39 pm</a></div>

		<div class="comment-body"><p>Thanks for the follow up!</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-8">
		<div id="comment-8">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">Greg</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-8">June 12, 2006 at 9:55 pm</a></div>

		<div class="comment-body"><p>That&#8217;s a good question, you are correct that I forgot to mention this, I will add a section to add this. </p>
<p>This will have 2 distinct behaviors (one when inlined one when not) </p>
<p>With inlining it is smart enough to realize what you are doing (and to undo it) </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0, j = length.Length; i &lt; j; i++) { <br />00000014 &nbsp;xor &nbsp; &nbsp; &nbsp; &nbsp; edx,edx <br />00000016 &nbsp;mov &nbsp; &nbsp; &nbsp; &nbsp; eax,dword ptr [ecx+4] <br />00000019 &nbsp;test &nbsp; &nbsp; &nbsp; &nbsp;eax,eax <br />0000001b &nbsp;jle &nbsp; &nbsp; &nbsp; &nbsp; 00000026 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;total |= i; <br />0000001d &nbsp;or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;esi,edx <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0, j = length.Length; i &lt; j; i++) { <br />0000001f &nbsp;add &nbsp; &nbsp; &nbsp; &nbsp; edx,1 <br />00000022 &nbsp;cmp &nbsp; &nbsp; &nbsp; &nbsp; edx,eax <br />00000024 &nbsp;jl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000001D <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </p>
<p>This is identical to the code produced but i&lt;length.Length </p>
<p>Without inlining it will put it into the preamble of the loop producing functional equivalent results to the other hoisted examples (although slightly different orderring and obviously the variable maintains a better scope)&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) { <br />00000013 &nbsp;xor &nbsp; &nbsp; &nbsp; &nbsp; esi,esi <br />00000015 &nbsp;mov &nbsp; &nbsp; &nbsp; &nbsp; ecx,eax <br />00000017 &nbsp;xor &nbsp; &nbsp; &nbsp; &nbsp; edx,edx <br />00000019 &nbsp;cmp &nbsp; &nbsp; &nbsp; &nbsp; dword ptr [ecx],ecx <br />0000001b &nbsp;call &nbsp; &nbsp; &nbsp; &nbsp;792666A8 <br />00000020 &nbsp;test &nbsp; &nbsp; &nbsp; &nbsp;eax,eax <br />00000022 &nbsp;jle &nbsp; &nbsp; &nbsp; &nbsp; 0000002D <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;total |= i; <br />00000024 &nbsp;or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;edi,esi <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) { <br />00000026 &nbsp;add &nbsp; &nbsp; &nbsp; &nbsp; esi,1 <br />00000029 &nbsp;cmp &nbsp; &nbsp; &nbsp; &nbsp; esi,eax <br />0000002b &nbsp;jl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00000024 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </p>
<p>The key thing to notice is that the JIT still does not realize what we are doing with array bounds hoists &#8230; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) {<br />00000016&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi,esi <br />00000018&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,edi <br />0000001a&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,edx <br />0000001c&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr [ecx],ecx <br />0000001e&nbsp; call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 792664C8 <br />00000023&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax <br />00000025&nbsp; jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000039 <br />00000027&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,dword ptr [edi+4] <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total |= length[i];<br />0000002a&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi,edx <br />0000002c&nbsp; jae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000003F <br />0000002e&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,dword ptr [edi+esi*4+8] <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0, j = length.GetUpperBound(0); i &lt; j; i++) {<br />00000032&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi,1 <br />00000035&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi,eax <br />00000037&nbsp; jl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000002A <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>Good catch! </p>
<p>Cheers, </p>
<p>Greg</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
		<li class="comment even thread-even depth-1" id="li-comment-7">
		<div id="comment-7">
		<div class="comment-author vcard">
			<img alt='' src='http://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=40' class='avatar avatar-40 photo avatar-default' height='40' width='40' />			<cite class="fn">Mark Lubischer</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="http://codebetter.com/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#comment-7">June 12, 2006 at 8:12 pm</a></div>

		<div class="comment-body"><p>Well written article, quite interesting to see the optimization done by the compiler.</p>
<p>As I was reading through it, I was wondering about how a locally scoped hoist would be handled by the JIT optimizer:</p>
<p>        int total = 0;<br />
        int[] length = new int[10000];</p>
<p>        for (int i = 0, j = length.Length; i < j; i++)<br />
        {<br />
            total |= i;<br />
        }</p>
</div>

		<div class="reply">
					</div>
	</div>

	</li>
			</ol>



								<div id="respond">
				<h3 id="reply-title">Leave a Reply <small><a rel="nofollow" id="cancel-comment-reply-link" href="/gregyoung/2006/06/11/an-in-depth-look-at-for-loops/#respond" style="display:none;">Cancel reply</a></small></h3>
									<p class="must-log-in">You must be <a href="http://codebetter.com/gregyoung/wp-login.php?redirect_to=http%3A%2F%2Fcodebetter.com%2Fgregyoung%2F2006%2F06%2F11%2Fan-in-depth-look-at-for-loops%2F">logged in</a> to post a comment.</p>												</div><!-- #respond -->
						
</div><!-- #comments -->

		</div><!-- #main -->
			<div id="sidebar" class="grid_4">

		<div id="primary" class="widget-area">
			<ul class="xoxo">
				<div class="ad-container">
					<a target="_blank" href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/entrypage/version-6-new-features?utm_source=cb&utm_medium=button&utm_term=4328&utm_content=app6release&utm_campaign=antsperformanceprofiler"><img width="125" height="125" border="0" title="" alt="" src="http://s3.amazonaws.com/CodeBetter/Creative/ANTSPP5_125x125_M1.gif"></a>
					<embed width="125" height="125" flashvars="clickTARGET=_blank&amp;clickTAG=http%3A%2F%2Fd1.openx.org%2Fck.php%3Foaparams%3D2__bannerid%3D62753__zoneid%3D29419__cb%3Da0471ce5e8__r_id%3Dd42118811971f057012db20aa261c5c1__r_ts%3Dldef6x__oadest%3Dhttp%253A%252F%252Fwww.jetbrains.com%252Fresharper%252F%253Frs4cb125" allowscriptaccess="always" quality="high" name="Advertisement" id="Advertisement" style="" src="http://s3.amazonaws.com/CodeBetter/Creative/tc_125x125_simple2.swf" type="application/x-shockwave-flash">
				</div>
			
				<li id="user_bio-2" class="widget-container widget_user_bio"><h3 class="widget-title"></h3>One of these days I will add something to my user profile! For now, I shall remain mysterious.
</li>		
						
			</ul>
			
		</div><!-- #primary .widget-area -->
		
		<div id="secondary" class="widget-area">
				<script type="text/javascript" src="http://engine.theloungenet.com/z/15/adzerk1_2_5"></script>
				<div id="adzerk1"></div>
				
				<ul class="xoxo">		
									</ul>	
				
				<a target="_blank" href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/entrypage/version-6-csharp?utm_source=cb&utm_medium=rectangle&utm_term=4327&utm_content=app6release&utm_campaign=antsperformanceprofiler"><img width="300" height="250" border="0" title="" alt="" src="http://s3.amazonaws.com/CodeBetter/Creative/APP6_Launch_C%23_Jun10_300x250_M1.gif?AWSAccessKeyId=0KMA35HT86EVXB99Z302&amp;Expires=1458095516&amp;Signature=BIBDilUaLnZe1uKfVKyyTBxr%2BvE%3D"></a>
				
		</div><!-- #secondary .widget-area -->			</div><!--sidebar-->
		</div><!-- #container -->
</div><!-- end div tabs see header.php -->
	
	<div id="footer">
		<div class="container_12">
		<div id="footer-widget-area">
				<div class="grid_4">					
					<ul>
					<li><a href="http://codebetter.com" title="home">Home</a></li>
					<li class="page_item page-item-2"><a href="http://codebetter.com/about/" title="About">About</a></li>
<li class="page_item page-item-8"><a href="http://codebetter.com/codebetter-ci/" title="CodeBetter CI">CodeBetter CI</a></li>
<li class="page_item page-item-6"><a href="http://codebetter.com/community/" title="Community">Community</a></li>
<li class="page_item page-item-10"><a href="http://codebetter.com/editors/" title="Editors">Editors</a></li>
<li class="page_item page-item-41"><a href="http://codebetter.com/globalsearch/" title="Search Results">Search Results</a></li>
					<li><a href="http://feeds.feedburner.com/CodeBetter" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon16x16.png" alt="" style="vertical-align:middle;border:0"/></a><a href="http://feeds.feedburner.com/CodeBetter"><img src="http://feeds.feedburner.com/~fc/CodeBetter?bg=FFFFFF&amp;fg=2E9BD2&amp;anim=1" height="26" width="88" style="vertical-align:middle;border:0"/></a></li>
					</ul>
				</div><!-- #second .widget-area -->
				<div class="grid_4">
					
					<h3>Friends of CodeBetter.Com</h3>
<ul>

<li><a href="/blogs/products/pages/64386.aspx">Red-Gate Tools For SQL and .NET</a></li>
<li><a href="/blogs/products/pages/64615.aspx">Telerik</a></li>
<li><a href="/blogs/products/pages/142174.aspx">JetBrains - ReSharper</a></li>
<li><a href="/blogs/products/pages/Beyond-Compare.aspx">Beyond Compare</a></li>
<li><a href="/blogs/products/pages/.NET-Memory-Profiler.aspx">.NET Memory Profiler</a></li>
<li><a href="http://www.ndepend.com/">NDepend</a></li>
<li><a href="http://www.sapphiresteel.com/">Ruby In Steel</a></li>
<li><a href="http://www.slickedit.com/">SlickEdit</a></li>
<li><a href="http://www.gurock.com/products/smartinspect/">SmartInspect .NET Logging</a></li>
<li>NGEDIT: <a href="http://www.viemu.com/">ViEmu</a> and <a href="http://www.codekana.com/">Codekana</a> </li>
<li><a href="http://www.devexpress.com/" target="_blank">DevExpress</a></li>
<li><a href="http://nhprof.com" target="_blank">NHibernate Profiler</a></li>
<li><a href="http://unfuddle.com" target="_blank">Unfuddle</a></li>
<li><a href="http://www.balsamiq.com/products/mockups" target="_blank">Balsamiq Mockups</a></li>
<li><a href="http://scrumy.com" target="_blank">Scrumy</a> &lt;-- NEW Friend!</li>

	</ul>				
				</div><!-- #third .widget-area -->
				<div class="grid_4">
					CodeBetter.Com &copy; '11<br />
						Stuff you need to Code Better!<br />
				Proudly powered by <span id="generator-link"><a href="http://wordpress.org/" title="Semantic Personal Publishing Platform" rel="generator">WordPress</a></span>.					
				</div><!-- #fourth .widget-area -->
			</div><!-- #footer-widget-area -->		
		
			</div><!-- end div.container_12 -->

	</div><!-- end div#footer -->
		
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-531207-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.83b'></script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCSharp.js?ver=3.0.83b'></script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushRuby.js?ver=3.0.83b'></script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushJScript.js?ver=3.0.83b'></script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushXml.js?ver=3.0.83b'></script>
<script type='text/javascript' src='http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/third-party-brushes/shBrushFSharp.js?ver=3.0.83b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.83b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://cdn1.codebetter.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.83b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
    SyntaxHighlighter.defaults['tab-size'] = 2;
    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.defaults['wrap-lines'] = false; 
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.all();
</script>
 
</body>
</html>
<!-- Dynamic page generated in 0.443 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2011-01-27 09:39:09 -->
<!-- super cache -->