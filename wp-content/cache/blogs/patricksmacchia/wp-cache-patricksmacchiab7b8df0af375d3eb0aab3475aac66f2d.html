<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Non-trivial and real-world feedbacks on writing Unit-Tests</title>
	<atom:link href="http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/feed/" rel="self" type="application/rss+xml" />
	<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/</link>
	<description>CodeBetter.Com - Stuff you need to Code Better!</description>
	<lastBuildDate>Thu, 01 Nov 2012 14:05:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
	<item>
		<title>By: Vince Bullinger</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1608</link>
		<dc:creator>Vince Bullinger</dc:creator>
		<pubDate>Wed, 21 Mar 2012 14:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1608</guid>
		<description> Just randomly saying stuff doesn&#039;t make it so. Why do you believe in number one? The author put out good reasons as to why you&#039;re wrong and you basically just said &quot;Nuh uh!&quot;

He never said or even implied what you spoke against number two. In fact, you two seem to be in agreement.</description>
		<content:encoded><![CDATA[<p> Just randomly saying stuff doesn&#8217;t make it so. Why do you believe in number one? The author put out good reasons as to why you&#8217;re wrong and you basically just said &#8220;Nuh uh!&#8221;</p>
<p>He never said or even implied what you spoke against number two. In fact, you two seem to be in agreement.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tomek Kaczanowski</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1551</link>
		<dc:creator>Tomek Kaczanowski</dc:creator>
		<pubDate>Fri, 27 Jan 2012 21:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1551</guid>
		<description>Interesting, but:
1) test first is the right way to go,
2) believing that 100% coverage means high quality tests and high quality code is a fallacy
</description>
		<content:encoded><![CDATA[<p>Interesting, but:<br />
1) test first is the right way to go,<br />
2) believing that 100% coverage means high quality tests and high quality code is a fallacy</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: psmacchia</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1535</link>
		<dc:creator>psmacchia</dc:creator>
		<pubDate>Sun, 15 Jan 2012 16:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1535</guid>
		<description>You can first write tests, then code that is de-facto testable! I don&#039;t call this way of doing test-first, since here I am talking of an iterative process where you write a few tests, then write the few corresponding lines of code and methods, and repeat until the features and classes are completely implemented and 100% covered by tests.

With experience one can anticipates how to design the code as testable,. Personaly I often write first the code, then the associated tests, then repeat again.

Calling this iterative process test-first or code-first is just a philosophical chicken and egg problem. Once again the key is the experience, that makes the design of the code and the tests two  intricated sides of a unique problem.
</description>
		<content:encoded><![CDATA[<p>You can first write tests, then code that is de-facto testable! I don&#8217;t call this way of doing test-first, since here I am talking of an iterative process where you write a few tests, then write the few corresponding lines of code and methods, and repeat until the features and classes are completely implemented and 100% covered by tests.</p>
<p>With experience one can anticipates how to design the code as testable,. Personaly I often write first the code, then the associated tests, then repeat again.</p>
<p>Calling this iterative process test-first or code-first is just a philosophical chicken and egg problem. Once again the key is the experience, that makes the design of the code and the tests two  intricated sides of a unique problem.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Christia Bjerre</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1533</link>
		<dc:creator>Christia Bjerre</dc:creator>
		<pubDate>Sun, 15 Jan 2012 09:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1533</guid>
		<description>Thanks for a short and useful test pratice guide. Keeping in line with what you write here will help make better software faster and with high confidence.

The challenge is as usual how to make sure we don&#039;t write code that is hard to test?</description>
		<content:encoded><![CDATA[<p>Thanks for a short and useful test pratice guide. Keeping in line with what you write here will help make better software faster and with high confidence.</p>
<p>The challenge is as usual how to make sure we don&#8217;t write code that is hard to test?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: psmacchia</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1532</link>
		<dc:creator>psmacchia</dc:creator>
		<pubDate>Fri, 13 Jan 2012 15:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1532</guid>
		<description>Not yet but the video looks pretty awesome :)</description>
		<content:encoded><![CDATA[<p>Not yet but the video looks pretty awesome <img src='http://cdn1.codebetter.com/wp-includes/images/smilies/icon_smile.gif' alt=':)' class='wp-smiley' /> </p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rodney Richardson</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1531</link>
		<dc:creator>Rodney Richardson</dc:creator>
		<pubDate>Fri, 13 Jan 2012 12:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1531</guid>
		<description>If you require the same initialization/zetup for different test fixtures, consider inheritence with the setup on the base class. This still allows the freedom of one fixture per class, and shared setup code.</description>
		<content:encoded><![CDATA[<p>If you require the same initialization/zetup for different test fixtures, consider inheritence with the setup on the base class. This still allows the freedom of one fixture per class, and shared setup code.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: garethevans1986</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1530</link>
		<dc:creator>garethevans1986</dc:creator>
		<pubDate>Fri, 13 Jan 2012 11:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1530</guid>
		<description>Have you tried http://www.ncrunch.net/ - Watch the video on the site.
GE</description>
		<content:encoded><![CDATA[<p>Have you tried http://www.ncrunch.net/ - Watch the video on the site.<br />
GE</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: psmacchia</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1529</link>
		<dc:creator>psmacchia</dc:creator>
		<pubDate>Fri, 13 Jan 2012 09:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1529</guid>
		<description>I would say that 100% coverage means pretty much 100% correctness, if (and only if) the code tested is stuffed with contract assertions. Indeed, in such conditions a statement covered by tests fullfils its unit action and all contextual data values are in well defined ranges, checked by contract assertions. The number of touch count is not really relevant. For example, if I know that a piece of code works fine for all positive integers,  I don&#039;t need to test all 2 Billions positive values to increase the number of touch. Testing the 4 values 1, 10, 100.000, and int.MaxValue should be enough.
To digress a bit, 100% coverage is not actually 100% coverage because of the way .NET code coverage tools works. Language construct such as ternary operator, inner method calls, or linq query are considered as one statement (i.e one monolithic breakpoint) by code coverage tools. For example if just the false expression of a ternary operator is covered, the  true expression is seen as covered as well.Hopefully, NCover is smarter on that and proposes the metric branch coverage which is more fine grained than the basic code coverage, and can handle this limitation of monolithic breakpoint.</description>
		<content:encoded><![CDATA[<p>I would say that 100% coverage means pretty much 100% correctness, if (and only if) the code tested is stuffed with contract assertions. Indeed, in such conditions a statement covered by tests fullfils its unit action and all contextual data values are in well defined ranges, checked by contract assertions. The number of touch count is not really relevant. For example, if I know that a piece of code works fine for all positive integers,  I don&#8217;t need to test all 2 Billions positive values to increase the number of touch. Testing the 4 values 1, 10, 100.000, and int.MaxValue should be enough.<br />
To digress a bit, 100% coverage is not actually 100% coverage because of the way .NET code coverage tools works. Language construct such as ternary operator, inner method calls, or linq query are considered as one statement (i.e one monolithic breakpoint) by code coverage tools. For example if just the false expression of a ternary operator is covered, the  true expression is seen as covered as well.Hopefully, NCover is smarter on that and proposes the metric branch coverage which is more fine grained than the basic code coverage, and can handle this limitation of monolithic breakpoint.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Steve Py</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1528</link>
		<dc:creator>Steve Py</dc:creator>
		<pubDate>Thu, 12 Jan 2012 22:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1528</guid>
		<description>One point I would add is that sometimes 100% coverage isn&#039;t 100%. With code that may have several combinations (Generally a candidate for re-factoring and simplification, but we&#039;re talking about real-world systems) you cannot merely trust a 100% coverage stat without considering the &quot;touch count&quot; for how many times each line/statement was touched by tests. 100% merely means each line was touched _at least once_. Complex methods with touch-counts of 1 should scream of possible bugs and it would be a dangerous assumption that they&#039;re safe just because they read 100% coverage.</description>
		<content:encoded><![CDATA[<p>One point I would add is that sometimes 100% coverage isn&#8217;t 100%. With code that may have several combinations (Generally a candidate for re-factoring and simplification, but we&#8217;re talking about real-world systems) you cannot merely trust a 100% coverage stat without considering the &#8220;touch count&#8221; for how many times each line/statement was touched by tests. 100% merely means each line was touched _at least once_. Complex methods with touch-counts of 1 should scream of possible bugs and it would be a dangerous assumption that they&#8217;re safe just because they read 100% coverage.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: psmacchia</title>
		<link>http://codebetter.com/patricksmacchia/2012/01/10/non-trivial-and-real-world-feedbacks-on-writing-unit-tests/#comment-1527</link>
		<dc:creator>psmacchia</dc:creator>
		<pubDate>Thu, 12 Jan 2012 19:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://codebetter.com/patricksmacchia/?p=472#comment-1527</guid>
		<description>Of course if you estimate that you need more than one test fixture class, you are free to create many. In general, a class that needs many test fixture class might violate the Single Responsability Principle: 
http://en.wikipedia.org/wiki/Single_responsibility_principle

Concerning the situation you described with multi-setup, it could be preferable to keep all tests in the same test fixure class with each test responsible for calling the right init. But if you are talking of dozens of tests, having many test fixture class makes sense, just to group tests appropriately.</description>
		<content:encoded><![CDATA[<p>Of course if you estimate that you need more than one test fixture class, you are free to create many. In general, a class that needs many test fixture class might violate the Single Responsability Principle: <br />
<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow">http://en.wikipedia.org/wiki/Single_responsibility_principle</a></p>
<p>Concerning the situation you described with multi-setup, it could be preferable to keep all tests in the same test fixure class with each test responsible for calling the right init. But if you are talking of dozens of tests, having many test fixture class makes sense, just to group tests appropriately.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.376 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2012-11-09 23:21:37 -->
